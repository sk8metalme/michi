# 並列タスク分析ルール

## 目的

複数のタスクが並列実行可能かどうかを判定し、適切に `(P)` マーカーを付与する。並列実行可能なタスクを識別することで、開発効率を最大化し、実装スケジュールを最適化する。

## 適用場面

- `/michi:create-tasks` コマンドで `--sequential` フラグが**指定されていない**時
- タスク生成時に並列化の判断が必要な時
- タスク依存関係の分析時

## ルール詳細

### 1. 並列実行の定義

**並列実行可能（Parallel）とは**:
- 複数のタスクが同時に実行できる
- 互いに依存関係がない
- 共有リソースの競合がない
- 実装順序が自由

**`(P)` マーカーの意味**:
- タスク名の後に付与: `## 1.2 データモデル実装 (P)`
- このタスクは他のタスクと並列実行可能であることを示す

### 2. 並列実行可能の判定基準

**以下の条件をすべて満たす場合、並列実行可能**:

#### 2.1 依存関係の独立性
- **ファイルレベル**: 異なるファイルを編集する
- **モジュールレベル**: 異なるモジュール/パッケージを扱う
- **レイヤーレベル**: 同じレイヤー内で独立したコンポーネント

**例（並列可能）**:
- タスクA: `src/user/UserModel.ts` を実装
- タスクB: `src/product/ProductModel.ts` を実装
- 理由: 異なるファイル、異なるモジュール

**例（並列不可）**:
- タスクA: `UserModel` の基底クラスを実装
- タスクB: `UserModel` を継承したクラスを実装
- 理由: タスクBがタスクAに依存

#### 2.2 インターフェースの独立性
- **共通インターフェースが確定している**: 既存のインターフェースを使用
- **新しいインターフェースが不要**: 互いに新しいインターフェースを必要としない
- **型定義が安定している**: 型定義の変更が他に影響しない

**例（並列可能）**:
- タスクA: 既存の `IRepository` インターフェースを実装した `UserRepository`
- タスクB: 既存の `IRepository` インターフェースを実装した `ProductRepository`
- 理由: 共通インターフェースが確定済み

**例（並列不可）**:
- タスクA: 新しいインターフェース `IAuthService` を定義
- タスクB: `IAuthService` を実装した `AuthService`
- 理由: タスクBがタスクAの成果物に依存

#### 2.3 データの独立性
- **データベーステーブル**: 異なるテーブルを扱う
- **ドメインモデル**: 異なるドメインモデル
- **状態管理**: 異なるストア/コンテキスト

**例（並列可能）**:
- タスクA: `users` テーブルのマイグレーション
- タスクB: `products` テーブルのマイグレーション
- 理由: 異なるテーブル

**例（並列不可）**:
- タスクA: `users` テーブルに `role_id` カラムを追加
- タスクB: `users` テーブルの `role_id` を使用したクエリ実装
- 理由: タスクBがタスクAの成果物に依存

#### 2.4 ビジネスロジックの独立性
- **機能の独立**: 異なるユースケース
- **処理フローの独立**: 互いに呼び出さない
- **副作用の独立**: 互いの処理結果に影響しない

**例（並列可能）**:
- タスクA: ユーザー登録機能
- タスクB: 商品検索機能
- 理由: 完全に独立した機能

**例（並列不可）**:
- タスクA: ユーザー認証機能
- タスクB: 認証が必要な商品購入機能
- 理由: タスクBがタスクAに依存

### 3. 並列実行不可の判定基準

**以下の条件のいずれかに該当する場合、並列実行不可**:

#### 3.1 順序依存
- タスクAの成果物がタスクBの前提条件
- タスクAで定義したものをタスクBで使用
- タスクAのテストがタスクBの実装前提

#### 3.2 共有リソースの競合
- 同じファイルを編集
- 同じデータベーステーブルのスキーマ変更
- 同じ設定ファイルの変更

#### 3.3 統合の必要性
- タスクAとタスクBの統合テストが必要
- 互いの実装を確認してから次に進む必要がある
- 設計判断が互いに影響する

#### 3.4 レイヤー間の依存
- 下位レイヤー → 上位レイヤーの順序が必要
- インフラ → ドメイン → アプリケーションの順序
- モデル → リポジトリ → サービス → コントローラーの順序

### 4. `(P)` マーカーの付与ルール

**付与タイミング**:
- タスク生成時に判定
- `--sequential` フラグが**指定されていない**場合のみ
- テンプレート `{{MICHI_DIR}}/settings/templates/specs/tasks.md` のフォーマットをサポート

**付与位置**:
- 主要タスクレベル: `## 1.2 データモデル実装 (P)`
- サブタスクレベル: `- [ ] 1.2.1 UserModel実装 (P)`
- 両方のレベルで付与可能

**付与しない場合**:
- シーケンシャルモード（`--sequential` フラグ指定時）
- 依存関係がある場合
- 順序が重要な場合

### 5. 分析手順

**ステップ1: ルールファイルの読み込み**:
- `{{MICHI_DIR}}/settings/rules/tasks-parallel-analysis.md` を読み取り
- 並列判定基準を理解

**ステップ2: タスク依存関係の分析**:
- 各タスクの入力と出力を特定
- ファイル、モジュール、データの依存関係をマッピング
- 順序制約を特定

**ステップ3: 並列グループの識別**:
- 依存関係のないタスクをグループ化
- 同じグループ内のタスクは並列実行可能
- グループ間は順序実行

**ステップ4: `(P)` マーカーの付与**:
- 並列実行可能と判定されたタスクに `(P)` を付与
- テンプレートフォーマットに従って記載

## 注意事項

### シーケンシャルモード

**`--sequential` フラグ指定時**:
- すべてのタスクを順序実行として扱う
- `(P)` マーカーは一切付与しない
- 並列分析をスキップ

### 保守的な判定

**迷った場合**:
- 並列実行可能と判定しない（安全側に倒す）
- 後から並列化するより、順序実行で安全に進める

### ドキュメント化

**並列判定の理由**:
- タスク説明に並列実行可能な理由を簡潔に記載
- 例: "独立したモジュールのため並列実行可能"

### テストタスクの並列化

**テストの並列実行**:
- 単体テストは基本的に並列実行可能
- 統合テストは依存関係を慎重に判定
- E2Eテストは共有リソース（DB、API）を考慮

## 例

### 例1: 並列実行可能

```markdown
## 1. データ層実装
- [ ] 1.1 UserModelの実装 (P)
  - 要件: 1, 2
  - 独立したモデル、他のモデルに依存しない
- [ ] 1.2 ProductModelの実装 (P)
  - 要件: 3, 4
  - 独立したモデル、他のモデルに依存しない
```

### 例2: 並列実行不可

```markdown
## 2. 認証機能実装
- [ ] 2.1 AuthServiceの実装
  - 要件: 5, 6
  - 認証ロジックの実装
- [ ] 2.2 AuthMiddlewareの実装
  - 要件: 7
  - 2.1の AuthService を使用（依存関係あり）
```

### 例3: 部分的に並列実行可能

```markdown
## 3. API実装
- [ ] 3.1 GET /users エンドポイント (P)
  - 要件: 8
  - UserRepository を使用（既存）
- [ ] 3.2 GET /products エンドポイント (P)
  - 要件: 9
  - ProductRepository を使用（既存）
- [ ] 3.3 POST /users エンドポイント
  - 要件: 10
  - 3.1のレビュー後に実装（順序依存）
```
